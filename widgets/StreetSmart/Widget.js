function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value}catch(error){reject(error);return}if(info.done){resolve(value)}else{return Promise.resolve(value).then(function(value){step('next',value)},function(err){step('throw',err)})}}return step('next')})}}var REQUIRE_CONFIG={async:true,locale:'en',paths:{'react':'https://unpkg.com/react@16.2.0/umd/react.production.min','react-dom':'https://unpkg.com/react-dom@16.2.0/umd/react-dom.production.min','openlayers':'https://cdnjs.cloudflare.com/ajax/libs/ol3/4.0.1/ol','lodash':'https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.min'}};require(REQUIRE_CONFIG,[],function(){return define(['dojo/_base/declare','dojo/on','dojo/dom','dijit/Tooltip','jimu/BaseWidget','esri/geometry/ScreenPoint','https://streetsmart.cyclomedia.com/api/v18.7/StreetSmartApi.js','./utils','./RecordingClient','./LayerManager','./MeasurementHandler','./OverlayManager'],function(declare,on,dom,Tooltip,BaseWidget,ScreenPoint,StreetSmartApi,utils,RecordingClient,LayerManager,MeasurementHandler,OverlayManager){//To create a widget, you need to derive from BaseWidget.
return declare([BaseWidget],{// Custom widget code goes here
baseClass:'jimu-widget-streetsmartwidget',// This property is `set by the framework when widget is loaded.
name:'Street Smart by CycloMedia',_zoomThreshold:null,_viewerType:StreetSmartApi.ViewerType.PANORAMA,_listeners:[],// CM properties
_cmtTitleColor:'#98C23C',_apiKey:'C3oda7I1S_49-rgV63wtWbgtOXcVe3gJWPAVWnAZK3whi7UxCjMNWzIJyv4Fmrcp',// Initial construction, might not be added to DOM yet.
postCreate:function postCreate(){this.inherited(arguments);this.wkid=parseInt(this.config.srs.split(':')[1]);utils.setProj4(CM.Proj4.getProj4());this._recordingClient=new RecordingClient({config:this.config,apiKey:this._apiKey,map:this.map});this._layerManager=new LayerManager({wkid:this.wkid,map:this.map,onRecordingLayerClick:this._handleRecordingClick.bind(this),setPanoramaViewerOrientation:this.setPanoramaViewerOrientation.bind(this),addEventListener:this.addEventListener.bind(this),config:this.config,removeEventListener:this.removeEventListener.bind(this)});this._measurementHandler=new MeasurementHandler({wkid:this.wkid,map:this.map,layer:this._layerManager.measureLayer,StreetSmartApi:StreetSmartApi});this._overlayManager=new OverlayManager({wkid:this.wkid,map:this.map,config:this.config,StreetSmartApi:StreetSmartApi});this._applyWidgetStyle();this._determineZoomThreshold()},startup:function startup(){this.inherited(arguments)},_handleRecordingClick:function _handleRecordingClick(event){var recordingId=event.graphic.attributes.recordingId;this.query(recordingId)},_initApi:function(){var _ref=_asyncToGenerator(/*#__PURE__*/regeneratorRuntime.mark(function _callee(){var _this=this;var CONFIG;return regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!(this.config.agreement!==true)){_context.next=3;break}alert(this.nls.agreementWarning);return _context.abrupt('return');case 3:CONFIG={targetElement:this.panoramaViewerDiv,// I have no idea where this comes from
username:this.config.uName,password:this.config.uPwd,apiKey:this._apiKey,srs:this.config.srs,locale:this.config.locale,configurationUrl:this.config.atlasHost+'/configuration',addressSettings:{locale:this.config.locale,database:'Nokia'}};return _context.abrupt('return',StreetSmartApi.init(CONFIG).then(function(){_this.loadingIndicator.classList.add('hidden');_this._bindInitialMapHandlers();_this._loadRecordings();_this._centerViewerToMap()}));case 5:case'end':return _context.stop();}}},_callee,this)}));function _initApi(){return _ref.apply(this,arguments)}return _initApi}(),_bindInitialMapHandlers:function _bindInitialMapHandlers(){var measurementChanged=StreetSmartApi.Events.measurement.MEASUREMENT_CHANGED;this.addEventListener(StreetSmartApi,measurementChanged,this._handleMeasurementChanged.bind(this));this.addEventListener(this.map,'extent-change',this._handleExtentChange.bind(this))},_handleMeasurementChanged:function _handleMeasurementChanged(e){var newViewer=e.detail.panoramaViewer;this._handleViewerChanged(newViewer);this._measurementHandler.draw(e)},/**
             * Handles the viewer change and event handler rebinding,
             * starting measurement mode changes the viewer.
             */_handleViewerChanged:function _handleViewerChanged(newViewer){// Handle initial viewer creation
if(!this._panoramaViewer&&newViewer){this._panoramaViewer=newViewer;this._layerManager.addLayers();this._bindViewerDependantEventHandlers();if(this.config.navigation!==true){this._hideNavigation()}if(this.config.measurement!==true){var measureBtn=StreetSmartApi.PanoramaViewerUi.buttons.MEASURE;this._panoramaViewer.toggleButtonEnabled(measureBtn)}this._handleImageChange();this._drawDraggableMarker();return}// Update the event handlers and everything else once the viewer changed
// Always make sure newViewer is set as newViewer can be undefined
// while this._panoramaViewer can be null
if(newViewer&&newViewer!==this._panoramaViewer){this.removeEventListener(this._viewChangeListener);this.removeEventListener(this._imageChangeListener);this._panoramaViewer=newViewer;this._bindViewerDependantEventHandlers({viewerOnly:true})}},// Adds event listeners which are automatically
// cleared onClose
addEventListener:function addEventListener(target,eventName,callback){var listener=on(target,eventName,callback);// Using dojo on doesn't always return a listener.
// For the panoramaViewer events it returns the panoramaViewer itself.
if(!listener.remove){listener={remove:function remove(){target.off(eventName,callback)}}}this._listeners.push(listener);return listener},removeEventListener:function removeEventListener(listener){listener.remove();var index=this._listeners.indexOf(listener);this._listeners.splice(index,1)},_openApiWhenZoomedIn:function _openApiWhenZoomedIn(){var _this2=this;this.zoomWarning.classList.remove('hidden');var listener=this.addEventListener(this.map,'zoom-end',function(zoomEvent){if(zoomEvent.level>_this2._zoomThreshold){_this2.zoomWarning.classList.add('hidden');_this2._initApi();_this2.removeEventListener(listener)}})},_bindViewerDependantEventHandlers:function _bindViewerDependantEventHandlers(options){var opts=Object.assign({},options,{viewerOnly:false});this._viewChangeListener=this.addEventListener(this._panoramaViewer,StreetSmartApi.Events.panoramaViewer.VIEW_CHANGE,this._handleConeChange.bind(this));this._imageChangeListener=this.addEventListener(this._panoramaViewer,StreetSmartApi.Events.panoramaViewer.IMAGE_CHANGE,this._handleImageChange.bind(this));if(!opts.viewerOnly){this.addEventListener(this.map,'zoom-end',this._handleConeChange.bind(this))}},// We do not use removeEventListener for this,
// as removing stuff in an array is a bad idea.
_removeEventListeners:function _removeEventListeners(){this._listeners.forEach(function(listener){listener.remove()});this._listeners=[]},_handleConeChange:function _handleConeChange(){this._layerManager.updateViewingCone(this._panoramaViewer)},_handleImageChange:function _handleImageChange(){this._handleConeChange();if(this.config.overlay===true){this._overlayManager.addOverlaysToViewer()}},_handleExtentChange:function _handleExtentChange(){this._loadRecordings()},_loadRecordings:function _loadRecordings(){var _this3=this;if(!this.config.navigation){return}if(this.map.getZoom()>this._zoomThreshold){this._recordingClient.load().then(function(response){_this3._layerManager.updateRecordings(response)})}else{this._layerManager.updateRecordings([])}},_applyWidgetStyle:function _applyWidgetStyle(){var panel=this.getPanel();// Set title color for Widget.
if(panel.titleNode){panel.titleNode.style.backgroundColor=this._cmtTitleColor;panel.titleLabelNode.style.color='white'}// Remove padding (white 'border') around viewer.
panel.containerNode.children[0].style.padding='0px'},_centerViewerToMap:function _centerViewerToMap(){var mapCenter=this.map.extent.getCenter();var mapSRS=this.config.srs.split(':')[1];var localCenter=utils.transformProj4js(mapCenter,mapSRS);// Manually fire these events as they are fired too early by the API,
// we can't listen to them yet.
this.query(localCenter.x+','+localCenter.y)},query:function query(_query){return StreetSmartApi.open(_query,{viewerType:[this._viewerType],srs:this.config.srs})},setPanoramaViewerOrientation:function setPanoramaViewerOrientation(orientation){var currentOrientation=this._panoramaViewer.getOrientation();this._panoramaViewer.setOrientation(Object.assign({},currentOrientation,orientation))},_determineZoomThreshold:function _determineZoomThreshold(){var maxMapZoom=this.map.getMaxZoom();var zoomThreshold=maxMapZoom-3;if(maxMapZoom>20){zoomThreshold=maxMapZoom-5}this._zoomThreshold=zoomThreshold;return zoomThreshold},_hideNavigation:function _hideNavigation(){var _this4=this;this._panoramaViewer.toggleNavbarVisible();this._panoramaViewer.toggleTimeTravelVisible();setTimeout(function(){_this4._panoramaViewer.toggleRecordingsVisible(false)})},onOpen:function onOpen(){var zoomLevel=this.map.getZoom();// Only open when the zoomThreshold is reached.
if(zoomLevel>this._zoomThreshold){this._initApi()}else{this._openApiWhenZoomedIn()}},onClose:function onClose(){StreetSmartApi.destroy({targetElement:this.panoramaViewerDiv});this.loadingIndicator.classList.remove('hidden');this._overlayManager.reset();this._removeEventListeners();this._layerManager.removeLayers();this._panoramaViewer=null},_drawDraggableMarker:function _drawDraggableMarker(){var nav=this.panoramaViewerDiv.querySelector('.navbar .navbar-right .nav');var exampleButton=nav.querySelector('.btn');// Draw the actual button in the same style as the other buttons.
var markerButton=dojo.create('button',{id:'addMapDropBtn',class:exampleButton.className,draggable:true,ondragend:this._handleMarkerDrop.bind(this)});nav.appendChild(markerButton);var toolTipMsg=this.nls.tipDragDrop;new Tooltip({connectId:markerButton,label:toolTipMsg,position:['above']})},_handleMarkerDrop:function _handleMarkerDrop(e){e.preventDefault();// Figure out on what pixels (relative to the map) the marker was dropped.
var containerOffset=this.map.container.getBoundingClientRect();var mapRelativePixels={x:e.clientX-containerOffset.x,y:e.clientY-containerOffset.y};var sPoint=new ScreenPoint(mapRelativePixels.x,mapRelativePixels.y);var mPoint=this.map.toMap(sPoint);var vPoint=utils.transformProj4js(mPoint,this.wkid);this.query(vPoint.x+','+vPoint.y)},// communication method between widgets
onReceiveData:function onReceiveData(name,widgetId,data,historyData){console.log('onReceiveData',name,widgetId,data,historyData)}})})});